package redissess

import (
	"context"
	"github.com/go-redis/redis/v8"
	"encoding/json"
	"io"
	"strings"
	"crypto/rand"
	"encoding/base32"
	"time"
	"net/http"
	// "fmt"
	// "math"
)



const DATA_NOT_FOUND = 0
const DATA_FOUND = 1

type ConnInfo struct {
	Addr string
	DB int
}

// type SessionOpt struct {
// 	Name string
// 	Path string
// 	Domain string
// 	Lifetime int
// 	HttpOnly bool
// 	Secure bool
// }


type SessionParam struct{
	// Cookie http.Cookie

	Name string
	Path string
	Domain string
	MaxAge int
	Secure bool
	HttpOnly bool
	SameSite http.SameSite
	Lifetime *int
}

type RedisClient struct {
	Client *redis.Client
}

var sessparam SessionParam

func New(conn ConnInfo,param SessionParam) *RedisClient {

	var rclient RedisClient

	nc := redis.NewClient(&redis.Options{
				Addr: conn.Addr,
				DB:   conn.DB,
			})

	if param.Lifetime == nil {
		param.Lifetime = &param.MaxAge
	}

	sessparam = param

	ctx := context.Background()

	_,err := nc.Ping(ctx).Result()

	if err != nil {
		return nil
	}

	rclient.Client = nc

	return &rclient
}

func (rc *RedisClient) Close() {
	rc.Close()
}


func createSessid() (string, error) {
	k := make([]byte, 64)
	if _, err := io.ReadFull(rand.Reader, k); err != nil {
		return "", err
	}
	return strings.TrimRight(base32.StdEncoding.EncodeToString(k), "="), nil
}


func (rc *RedisClient) Create(obj interface{}) (*http.Cookie,error) {

	str,err := createSessid()

	if err != nil {
		return nil,err
	}

	// limit := time.Now().Add(time.Duration(sessparam.MaxAge) * time.Second)

	err = rc.Set(str,obj)

	if err != nil {
		return nil,err
	}



	return newCookie(str),nil

	// return &http.Cookie{
	// 	Name : sessparam.Name,
	// 	Value : str,
	// 	Domain: sessparam.Domain,
	// 	Path : sessparam.Path,
	// 	MaxAge : sessparam.MaxAge,
	// 	HttpOnly : sessparam.HttpOnly,
	// 	Secure : sessparam.Secure,
	// 	SameSite: sessparam.SameSite,
	// },nil
}



func (rc *RedisClient) Set(key string,obj interface{}) error {

	jobj,err := json.Marshal(obj)

	 if err != nil {
	 	return err
	 }

	err = rc.Client.Set(context.Background(), 
					   key,
					   jobj,
					   time.Second*time.Duration(*sessparam.Lifetime),
			).Err()

	if err != nil {
  		return err
	}

	return nil
}

func (rc *RedisClient) Get(key string,obj interface{}) (*int,error) {
	
	ret := DATA_NOT_FOUND

	ctx := context.Background()

	data,err := rc.Client.Get(ctx,key).Result()

	if err == redis.Nil {
		return &ret,nil
	} 
	
	if err != nil {
		return nil,err
	}

	if obj != nil {
		err = json.Unmarshal([]byte(data),obj)

		if err != nil {
			return nil,err
		}
	}
	ret = DATA_FOUND

	if err = rc.setExpire(ctx,key) ; err != nil {

		return nil,err
	}

	return &ret,nil
}


func (rc *RedisClient) setExpire(ctx context.Context, key string) error {

	be := rc.Client.Expire(ctx,
						   key,
						   time.Second*time.Duration(*sessparam.Lifetime),
	 					  )

	if be.Err() != nil {
		return be.Err()
	}

	return nil

}

func (rc *RedisClient) IsExists(key string) (*int,error) {

	ctx := context.Background()

	n,err := rc.Client.Exists(ctx,key).Result()

	if err!=nil {
		return nil,err
	} 

	ret := DATA_NOT_FOUND

	if n > 0 {
		ret = DATA_FOUND

		if err = rc.setExpire(ctx,key) ; err != nil {
			return nil,err
		}

	}

	return &ret,nil	 
}

func (rc *RedisClient) Delete(key string) (*http.Cookie,error) {

	ctx := context.Background()

	if err := rc.Client.Del(ctx,key).Err(); err!=nil{
		return nil,err
	}

	// return newCookie(""),nil

	return &http.Cookie{
		Name : sessparam.Name,
		Value : "",
		Domain: sessparam.Domain,
		Path : sessparam.Path,
		MaxAge : -1,
		HttpOnly : sessparam.HttpOnly,
		Secure : sessparam.Secure,
		SameSite: sessparam.SameSite,
	},nil

}

func newCookie(value string ) *http.Cookie {

	return &http.Cookie{
		Name : sessparam.Name,
		Value : value,
		Domain: sessparam.Domain,
		Path : sessparam.Path,
		MaxAge : sessparam.MaxAge,
		HttpOnly : sessparam.HttpOnly,
		Secure : sessparam.Secure,
		SameSite: sessparam.SameSite,
	}
}


 func (rc *RedisClient) Regenerate(key string) (*http.Cookie,error) {

	var obj interface{}

	res,err := rc.Get(key,obj)

	if err != nil || *res==0 {
		return nil,err
	}

	_,err = rc.Delete(key)

	if err != nil {
		return nil,err
	}

	return rc.Create(obj)
 }